
User shinyquagsire23 on GitHub did some interesting work on reverse engineering, and we can find some useful information here: https://github.com/rockowitz/ddcutil/issues/100

> ok actually I managed to find the input switching in a service manual of all things (filename 32BL95UW.pdf, search `lg monitor service manual "DDC2AB"`), but it's not via VCPs, it's via the service/factory/manufacturer sidechannel "DDC2AB" (0x50 instead of 0x51)
> 
> Over USB HID (VID 0x043E, PID 0x9a39):
> `08 02 55 04 26 00 0b 37 50 84 03 f4 00 90 dd`
> 
> Over I2C:
> `50 84 03 f4 00 90 dd`
> 
> So it's DDC2AB Command 0xF4, values 0x90 (HDMI1) 0xD0 (DP) 0xD2 (USB-C). It operates the same as the input switcher as well, so if you're in PBP and the secondary is HDMI1, it will swap the displays if you set the primary to HDMI1.

So, we should generally be looking for the raw DDC message format in 

More importantly, we have an example DDC packet wrapped in the HID protocol format, which will be of great help.

## Protocol traces and analysis

Upon starting OnScreen Display Software
IN =>
0c 00 29 01 80 1a 06 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
OUT =>
0c 00 29 00 36 2e 3037 00 484944 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
             6  .  0 7     H I D
            NV NV NV NV

IN =>
08 01 29 03 05 00 03 37 51 82 01 c9 75 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
IN =>
08 02 29 04 0b 00 0b 37 51 82 01 c9 75 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
OUT =>
0f 02 29 00 6e 88 02 00 c9 01 ff ff 04 06 7e 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
                                    SV SV

IN =>
08 03 29 03 07 00 03 37 50 84 03 c9 00 06 76 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
IN =>
08 04 29 04 09 00 0b 37 50 84 03 c9 00 06 76 00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
OUT =>
0d 04 29 00 86 44 00 56 80 41 1b 00 70 000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
               DV


### Observed structure of a DDC request message

08 01 29 03 05 00 03 37518201c975
?? NN VV CC LL ?? XX DDC part

The NN part seems to be an incremental and overflowing counter. (We can see it overflow during software updates), probably used to match requests with responses.

The VV part seems to be a semi-randomly chosen value used throughout a session with the device. (This would supposedly allow multiple programs to access the device simultaneously.)

The CC part seems to be some kind of command information. 03 for a DDC request without response, and 04 for a DDC request with response ?
This is a bit cryptical, as the first byte also seems to be some kind of category or command. Although it is always 0x08 for DDC requests.

The LL part would be the DDC packet data length excepted the I2C address (0x37) when the command is 0x03, and the expected result length when the command is 0x04 ?

The XX part seems to be 0x03 when CC ix 0x03, and 0x0B when CC is 0x04

The DDC part of the message follows the standard DDC format, except that the I2C address is not shifted right (It usually would be 0x37 << 1 = 0x6E)
The signature seems to still consider the shifted value of the I2C address (0x6E, which is somewhat logical but weirdly inconsistent).

### Observed structure of a DDC response message

0f 02 29 00 6e880200c901ffff04067e
SS NN VV    DDC part

In the DDC response, the destination address field is missing, but the source address has the standard value of 0x6E.

The SS part seems to always be the total data length, including the byte itself. Still no idea as to what this value is supposed to be in the other direction.
E.g. We use 0C for the "handshake" that returns some info, and we get a response using 0C, which is exactly 12 bytes. But for the input, it was only 7 bytes.
For DDC messages, 8 bytes is the exact length of the header before the ddc data, so it could be that sometimes.


### Error Response ?

04 00 00 11


2A NN SS => After invalid data has been sent ?
